In this experiment, we will practice network reconnaissance: gathering information about a network, such as the network structure, applications and services, and vulnerabilities.

This experiment involves running a potentially disruptive application over a private network within your testbed slice. Take special care not to use this application in ways that may adversely affect other infrastructure outside of your slice! Users of GENI are responsible for ensuring compliance with the [GENI Resource Recommended User Policy](http://groups.geni.net/geni/raw-attachment/wiki/RUP/RUP.pdf). Users of CloudLab are responsible for ensuring compliance with the [CloudLab Acceptable Use Policy](https://www.cloudlab.us/aup.php)

It should take about 60-120 minutes to run this experiment.

You can run this experiment on GENI or on CloudLab. Refer to the testbed-specific prerequisites listed below.


<div style="border-color:#FB8C00; border-style:solid; padding: 15px;">
<h4 style="color:#FB8C00;"> GENI-specific instructions: Prerequisites</h4>

To reproduce this experiment on GENI, you will need an account on the <a href="http://groups.geni.net/geni/wiki/SignMeUp">GENI Portal</a>, and you will need to have <a href="http://groups.geni.net/geni/wiki/JoinAProject">joined a project</a>. You should have already <a href="http://groups.geni.net/geni/wiki/HowTo/LoginToNodes">uploaded your SSH keys to the portal and know how to log in to a node with those keys</a>.

</div>
<br>

<div style="border-color:#5e8a90; border-style:solid; padding: 15px;">
<h4 style="color:#5e8a90;"> Cloudlab-specific instructions: Prerequisites</h4>

To reproduce this experiment on Cloudlab, you will need an account on <a href="https://cloudlab.us/">Cloudlab</a>, you will need to have <a href="https://docs.cloudlab.us/users.html#%28part._join-project%29">joined a project</a>, and you will need to have <a href="https://docs.cloudlab.us/users.html#%28part._ssh-access%29">set up SSH access</a>.

</div>
<br>

## Background

The first step in an attack on a computer network is typically to gather information about the network. Relevant information includes:

* What hosts are on the network?
* What is the network structure?
* What applications and services are running on devices on this network?
* What vulnerabilities exist that may be exploited?

It is also important for network administrators to identify what an attacker might potentially learn in the network reconnaissance phase, so as to defend the network more effectively. In this experiment, we will practice using some basic tools for network reconnaissance to see what information may be discovered about a target network. 


## Run my experiment

For this experiment, we will reserve a network topology including a recon host, a target network with three hosts, and a router between them. From the recon host, we will attempt to learn about the hosts in the target network.

![](/blog/content/images/2019/02/recon-topology.png)

Follow the instructions for the testbed you are using (GENI or Cloudlab) to reserve the resources and log in to each of the hosts in this experiment. 


<div style="border-color:#FB8C00; border-style:solid; padding: 15px;">

<h4 style="color:#FB8C00;"> GENI-specific instructions: Reserve resources</h4>


<p>To set up this topology in the GENI Portal, create a slice, click on "Add Resources", and load the RSpec from the following URL: </p>

<p><a href="https://git.io/JtNmB">https://git.io/JtNmB</a></p>

<p>Refer to the <a href="https://fedmon.fed4fire.eu/overview/instageni">monitor website</a> to identify an InstaGENI site that has many "free VMs" available. Then bind to an InstaGENI site and reserve your resources. Wait for them to become available for login ("turn green" on your canvas) and then get the SSH details for each from the GENI portal.</p>

</div>

<br>

<div style="border-color:#5e8a90; border-style:solid; padding: 15px;">

<h4 style="color:#5e8a90;"> Cloudlab-specific instructions: Reserve resources</h4>

<p>To reserve resources on Cloudlab, open this profile page: </p>

<p>https://www.cloudlab.us/p/nyunetworks/education?refspec=refs/heads/network_recon</p>

<p>When you load this profile, you will see a warning about using a deprecated operating system. You can safely ignore this warning (we are deliberately using an old OS with vulnerabilities!).</p>

<p>Click "next", then select the Cloudlab project that you are part of and a Cloudlab cluster with available resources. (This experiment is compatible with any of the Cloudlab clusters.) Then click "next", and "finish".</p>

<p>Wait until all of the sources have turned green and have a small check mark in the top right corner of the "topology view" tab, indicating that they are fully configured and ready to log in. Then, click on "list view" to get SSH login details for the client, router, and server hosts, and SSH into each.</p>


</div>
<br>


The procedure above will set up network interfaces and install some applications on hosts in the target network. On the "recon" node, it will install two tools that we will use for network reconnaissance:

* [nmap](https://nmap.org/) ("Network Mapper") is a widely used scanner that works by sending various kinds of packets to a host or list of hosts. From the response, it can infer information about the existence of a host and about networked applications or services running on the host.
* [OpenVAS](http://openvas.org/) is a vulnerability scanner that matches information about networked services running on a host to a large database of known vulnerabilities.

When this process is complete, open an SSH session to the "recon" node and another SSH session to the "router" node.

### Host discovery

Our first step will be to try and discover the IP addresses of hosts on the target network using ICMP messages.

Certain Internet standards describe ICMP messages that hosts are required to process. For example [RFC 1122](http://www.rfc-editor.org/rfc/rfc1122.txt) specificies that hosts must respond to ICMP echo requests with an echo reply. Therefore, by sending an echo request to an address range and observing what echo requests come back, we can find out which addresses in the range currently have hosts on them. However, many hosts and firewalls block these packets rather than sending a reply or passing on the request, so this method is of limited reliability.

Try a basic ICMP echo request scan to find hosts. On the "router" node, use `tcpdump` to monitor traffic to and from the recon node - run

<pre>
sudo tcpdump -i eth1 -l -n | tee router-ping-scan.txt
</pre>

This command will 

* capture the traffic on a "router" interface between the "recon" host and the target network
* show output line-by-line, instead of buffering (that's what the `-l` does), and
* save the results in a file "router-ping-scan.txt" as well as displaying them in the terminal.

Leave this running, and on "recon", run

```
sudo nmap -sn -PE 10.10.2.0/24  | tee recon-ping-scan.txt
```

to send an ICMP Echo Request (as specified by the `-PE` flag) to all hosts in 10.10.2.0/24, and save the output in a file "recon-ping-scan.txt". When this scan is finished, you can use Ctrl+C to stop the `tcpdump` running on the router.

Make a note of which hosts on the target network `nmap` sent an ICMP echo request to. Which hosts on the target network responded to the ICMP request? Which hosts do you think are configured to ignore ICMP echo requests?

One host on the target network is configured to ignore ICMP messages, so it isn't detected by an ICMP scan. As an alternative, we'll try another method of host discovery: sending TCP SYN packets to a given TCP port, to all addresses in the range. 

* If there is a service listening on that port, the target will send back a SYN in response, alerting us that there is a host at that address. 
* If there is no service listening on that port, the target will send back a TCP Reset, still alerting us that there is a host at that address.

On the "router" node, run

```
sudo tcpdump -i eth1 -l -n | tee router-tcp-host-scan.txt
```

and leave this running. Then, on the "recon" node, run

```
sudo nmap -sn -PS80 10.10.2.0/24 | tee recon-tcp-host-scan.txt
```

where `-PS80` specifies that we will send a TCP SYN to port 80 of each host. When it's finished, use Ctrl+C to stop the `tcpdump` on the router.

Make a note of which hosts on the target network responded to the TCP SYN. What was the response in each case (i.e. what TCP flags were set)? Why might some hosts respond differently from others?


### Service and host fingerprinting

`nmap` can perform OS detection using TCP/IP stack fingerprinting: it will send a series of specific TCP and UDP packets to the remote host and examine the response. Since different operating systems and OS versions implement the TCP/IP stack slightly differently, the responses will contain clues that can help `nmap` determine the OS and version. (You can read more about this [here](https://nmap.org/book/osdetect.html).) `nmap` can also try and find out what networked service are listening for connections on a remote host, and what version of that service is running, by sending messages to commonly used ports for popular services and observing the responses. (You can read more about this [here](https://nmap.org/book/vscan.html).)


At this point, we should have identified the IP address of three hosts on the target network: 10.10.2.45, 10.10.2.97, 10.10.2.112. Now, we will attempt to discover what services are running on these hosts, what versions of these services, and what operating systems.


Use the `nano` editor to create a new file - run

```
nano list-of-ips.txt
```

on the "recon" host. Copy and paste the list of IP addresses into the file:

```
10.10.2.45
10.10.2.97
10.10.2.112
```

then use Ctrl+O (and Enter to confirm file name) to save the file, and Ctrl+X to quit the editor.

On "recon", run

<pre>
sudo nmap -A -sV -O -iL list-of-ips.txt  | tee recon-fingerprint.txt
</pre>

This will direct `nmap` to try and "fingerprint" each host on the list of IP addresses we have just created.

On each target host, run the following commands to collect information about the host operating system and the services running on it:

<pre>
uname -sr | tee $(hostname -s)-os-name-version.txt
apache2 -v | tee $(hostname -s)-apache-version.txt
sshd -V 2>&1 | tee $(hostname -s)-openssh-version.txt
postconf -d mail_version | tee $(hostname -s)-postfix-version.txt
mysql --version  | tee $(hostname -s)-mysql-version.txt
</pre>

where:

* the first command (`uname -sr`) gets the name of the operating system and the OS kernel version.
* the second command (`apache2 -v`) tries to get the version number of the local Apache web server, if it is installed. 
* the third command (`sshd -V`) tries to get the version number of the local OpenSSH server, if it is installed. 
* the fourth command (`postconf -d mail_version`) tries to get the version number of the local Postfix mail server, if it is installed. 
* the fifth command (`mysql --version`) tries to get the version number of the local mySQL database server, if it is installed. 

For each of the last four commands: if the service is installed, you will see some output that includes the version number; if not, you will get an error message or a message that tells you how to install the service.

Which target host is running the Apache web server (default TCP port 80)? Which is running the Postfix STMP mail server (default TCP port 25)? Which is running the MySQL database server (default TCP port 3306)? Does `nmap` successfully collect this information? Compare the actual Linux kernel version and service version for each host, to `nmap`'s guess.

### Vulnerability discovery

> **Note**: This section is included for reference. However as of February 2022 it is not currently working; it needs to be updated to reflect the latest OpenVAS install process.

Finally, we will use OpenVAS to run a basic vulnerability scan on the hosts in our target network. 

The Rspec for this experiment should have initiated the process of installing and configuring OpenVAS on the "recon" node. However, this process can take a very long time (since it includes retrieving the latest versions of the vulnerabilities databases). Before you continue, check on the progress of the OpenVAS installation by viewing the log file -

```
tail -f /var/tmp/startup-0.txt
```

If it is finished, it will say "Installation complete" and will give you a URL at which to open your admin panel at the end.


If your OpenVAS setup hasn't finished yet, and you should wait and check again another time. You may want to resume the next day, since the OpenVAS setup can take a *very* long time.

Once your OpenVAS setup is finished, you will open the OpenVAS browser-based interface. On the "recon" node, run

```
wget -qO- https://ipinfo.io/ip
```

to find out this host's public IP address. Then, in a browser, open the URL

[https://**IP**:9392](https://**IP**:9392)

where in place of **IP**, you substitute the public IP address you found. You will see a warning alerting you that "Your connection is not private" (or equivalent, depending on what browser you are using). Choose to proceed anyway (in Google Chrome, click "Advanced" and then "Proceed to... (unsafe)". 


> **Note**: On some GENI sites, the host site's firewall is not configured to allow services on arbitrary ports, like OpenVAS. If your browser refuses to even connect to the OpenVAS site, and you're sure the OpenVAS setup has finished, this may be the case on your GENI site!
> 
> You can make OpenVAS run on a standard HTTPS port by editing the file `/etc/default/gsad` and changing the port number to 443. Then, run `sudo service gsad restart`. Finally, try to load the URL, but on port 443 instead of 9392.

When the login loads, log in with username **admin** and password **admin**.

![](/blog/content/images/2019/02/openvas-login.png)



Log in to the OpenVAS interface with username `admin` and password `admin`.

To use OpenVAS, we must first set up a "target" for each host in the target network. Then, we have to add a "scan task" for each one.

Click on "Configuration > Targets". To add a target, click on the star icon near the top left of the screen. Add a name. Next to "Hosts", make sure "manual" is selected, and in the text entry space put a comma-separated list of IP addresses for hosts on the target network. Change the "Alive Test" setting to "Consider Alive". Leave other settings at their defaults, then click "Save".

![](/blog/content/images/2021/02/scan-targets.png)

Now, add a scan. From the menu bar, choose "Scans > Tasks". Use the star icon near the top left of the screen again to set up a "New Task". Give your scan a name. Under "Scan Targets" make sure the "target" you previously set up is selected. Leave all other settings at their defaults, then click "Save".

![](/blog/content/images/2019/02/scan-target-network.png)

Now you are ready to start your scan. In the task dashboard, you should see your scan listed by name. In the "Actions" section next to it you will find a green button with the "Play" (►) symbol on it; click this button to start the scan.

![](/blog/content/images/2019/02/view-scan-report.png)

To see the scan report, click on the number in parentheses in the "Reports" column next to your scan. This will show you the reports for the scan, including the current unfinished one:

![](/blog/content/images/2019/02/reports-dash.png)

Refresh the page to see the latest scan status. When the status shows as "Done", click on the "Date" column entry to see the report details. Then, you can click on any vulnerability in the report to see more details.

![](/blog/content/images/2019/02/vulnerability-list.png)

**Note**: If at some point you see the error message "An internal error occurred. Diagnostics: Could not authenticate to manager daemon.", click on "Assumed sane state" to continue.

## Notes

### Exercise

Use the data you have collected to answer the following questions, and show evidence to support your answers.

* **ICMP echo request scan**: Make a note of which hosts on the target network `nmap` sent an ICMP echo request to. Which hosts on the target network responded to the ICMP request? Which hosts do you think are configured to ignore ICMP echo requests?

* **TCP SYN scan**: Make a note of which hosts on the target network responded to the TCP SYN. What was the response in each case (i.e. what TCP flags were set)? Why might some hosts respond differently from others?

* **Service and host fingerprinting**: Which target host is running the Apache web server (default TCP port 80)? Which is running the Postfix STMP mail server (default TCP port 25)? Which is running the MySQL database server (default TCP port 3306)? Does `nmap` successfully collect this information? Compare the actual Linux kernel version and service version for each host, to `nmap`'s guess.