In this experiment, we will practice network reconnaissance: gathering information about a network, such as the network structure, applications and services, and vulnerabilities.

This experiment involves running a potentially disruptive application over a private network within your testbed slice. Take special care not to use this application in ways that may adversely affect other infrastructure outside of your slice! Users of CloudLab are responsible for ensuring compliance with the [CloudLab Acceptable Use Policy](https://www.cloudlab.us/aup.php)

It should take about 60-120 minutes to run this experiment.

You can run this experiment on CloudLab. Refer to the prerequisites listed below.


<div style="border-color:#5e8a90; border-style:solid; padding: 15px;">
<h4 style="color:#5e8a90;"> Cloudlab-specific instructions: Prerequisites</h4>

To reproduce this experiment on Cloudlab, you will need an account on <a href="https://cloudlab.us/">Cloudlab</a>, you will need to have <a href="https://docs.cloudlab.us/users.html#%28part._join-project%29">joined a project</a>, and you will need to have <a href="https://docs.cloudlab.us/users.html#%28part._ssh-access%29">set up SSH access</a>.

</div>
<br>

## Background

The first step in an attack on a computer network is typically to gather information about the network. Relevant information includes:

* What hosts are on the network?
* What is the network structure?
* What applications and services are running on devices on this network?
* What vulnerabilities exist that may be exploited?

It is also important for network administrators to identify what an attacker might potentially learn in the network reconnaissance phase, so as to defend the network more effectively. In this experiment, we will practice using some basic tools for network reconnaissance to see what information may be discovered about a target network. 


## Run my experiment

For this experiment, we will reserve a network topology including a recon host, a target network with three hosts, and a router between them. From the recon host, we will attempt to learn about the hosts in the target network.

![](/blog/content/images/2019/02/recon-topology.png)

Follow the instructions to reserve the resources and log in to each of the hosts in this experiment. 


<div style="border-color:#5e8a90; border-style:solid; padding: 15px;">

<h4 style="color:#5e8a90;"> Cloudlab-specific instructions: Reserve resources</h4>

<p>To reserve resources on Cloudlab, open this profile page: </p>

<p>https://www.cloudlab.us/p/nyunetworks/education?refspec=refs/heads/network_recon</p>

<p>When you load this profile, you will see a warning about using a deprecated operating system. You can safely ignore this warning (we are deliberately using an old OS with vulnerabilities!).</p>

<p>Click "next", then select the Cloudlab project that you are part of and a Cloudlab cluster with available resources. (For this experiment, any of the following clusters are recommended: CloudLab Utah, CloudLab Clemson.) Then click "next", and "finish".</p>

<p>Wait until all of the sources have turned green and have a small check mark in the top right corner of the "topology view" tab, indicating that they are fully configured and ready to log in. Then, click on "list view" to get SSH login details for the client, router, and server hosts, and SSH into each.</p>


</div>
<br>


The procedure above will set up network interfaces and install some applications on hosts in the target network. On the "recon" node, it will install two tools that we will use for network reconnaissance:

* [nmap](https://nmap.org/) ("Network Mapper") is a widely used scanner that works by sending various kinds of packets to a host or list of hosts. From the response, it can infer information about the existence of a host and about networked applications or services running on the host.
* [Greenbone OpenVAS](http://openvas.org/) is a vulnerability scanner that matches information about networked services running on a host to a large database of known vulnerabilities.

When this process is complete, open an SSH session to the "recon" node and another SSH session to the "router" node.

#### Start OpenVAS (for later)

For the "Vulnerability Discovery" section at the end of this exercise, you will need to bring up an instance of Greenbone OpenVAS. This takes a while, so we will get it started right away. On the "recon" node, run

<pre>
docker compose -f /opt/greenbone-community-container/docker-compose.yml -p greenbone-community-edition up -d
</pre>

Once the terminal prompt returns, start watching the log files with

<pre>
docker compose -f /opt/greenbone-community-container/docker-compose.yml -p greenbone-community-edition logs -f
</pre>

At first you will see many instances of

<pre>
gvmd-1                 | psql: error: FATAL:  the database system is starting up
gvmd-1                 | waiting 1 second to retry psql connection
</pre>

as the system comes up, but then eventually you will see

<pre>
pg-gvm-1               | 2024-09-06 16:28:35.177 UTC [146] LOG:  database system is ready to accept connections
gvmd-1                 |  connection 
gvmd-1                 | ------------
</pre>

and then after a little while longer, it will show that its database of known vulnerabilities has been updated, e.g.

<pre>
gvmd-1                 | md manage:   INFO:2024-09-06 16h28.44 utc:277: sync_cert: Updating CERT info succeeded.
openvas-1              | libgvm util:MESSAGE:2024-09-06 16h29.21 utc:32: Updated NVT cache from version 0 to 202409060823
ospd-openvas-1         | OSPD[7] 2024-09-06 16:29:21,157: INFO: (ospd_openvas.daemon) Finished loading VTs. The VT cache has been updated from version 0 to 202409060823.
</pre>

When you see this, use Ctrl + C to stop watching the logs, and proceed with the rest of the experiment.


### Host discovery

Our first step will be to try and discover the IP addresses of hosts on the target network using ICMP messages.

Certain Internet standards describe ICMP messages that hosts are required to process. For example [RFC 1122](http://www.rfc-editor.org/rfc/rfc1122.txt) specificies that hosts must respond to ICMP echo requests with an echo reply. Therefore, by sending an echo request to an address range and observing what echo requests come back, we can find out which addresses in the range currently have hosts on them. However, many hosts and firewalls block these packets rather than sending a reply or passing on the request, so this method is of limited reliability.

Try a basic ICMP echo request scan to find hosts. On the "router" node, use `tcpdump` to monitor traffic to and from the recon node - run

<pre>
sudo tcpdump -i eth1 -l -n | tee router-ping-scan.txt
</pre>

This command will 

* capture the traffic on a "router" interface between the "recon" host and the target network
* show output line-by-line, instead of buffering (that's what the `-l` does), and
* save the results in a file "router-ping-scan.txt" as well as displaying them in the terminal.

Leave this running, and on "recon", run

```
sudo nmap -sn -PE 10.10.2.0/24  | tee recon-ping-scan.txt
```

to send an ICMP Echo Request (as specified by the `-PE` flag) to all hosts in 10.10.2.0/24, and save the output in a file "recon-ping-scan.txt". When this scan is finished, you can use Ctrl+C to stop the `tcpdump` running on the router.

Make a note of which hosts on the target network `nmap` sent an ICMP echo request to. Which hosts on the target network responded to the ICMP request? Which hosts do you think are configured to ignore ICMP echo requests?

One host on the target network is configured to ignore ICMP messages, so it isn't detected by an ICMP scan. As an alternative, we'll try another method of host discovery: sending TCP SYN packets to a given TCP port, to all addresses in the range. 

* If there is a service listening on that port, the target will send back a SYN in response, alerting us that there is a host at that address. 
* If there is no service listening on that port, the target will send back a TCP Reset, still alerting us that there is a host at that address.

On the "router" node, run

```
sudo tcpdump -i eth1 -l -n | tee router-tcp-host-scan.txt
```

and leave this running. Then, on the "recon" node, run

```
sudo nmap -sn -PS80 10.10.2.0/24 | tee recon-tcp-host-scan.txt
```

where `-PS80` specifies that we will send a TCP SYN to port 80 of each host. When it's finished, use Ctrl+C to stop the `tcpdump` on the router.

Make a note of which hosts on the target network responded to the TCP SYN. What was the response in each case (i.e. what TCP flags were set)? Why might some hosts respond differently from others?


### Service and host fingerprinting

`nmap` can perform OS detection using TCP/IP stack fingerprinting: it will send a series of specific TCP and UDP packets to the remote host and examine the response. Since different operating systems and OS versions implement the TCP/IP stack slightly differently, the responses will contain clues that can help `nmap` determine the OS and version. (You can read more about this [here](https://nmap.org/book/osdetect.html).) `nmap` can also try and find out what networked service are listening for connections on a remote host, and what version of that service is running, by sending messages to commonly used ports for popular services and observing the responses. (You can read more about this [here](https://nmap.org/book/vscan.html).)


At this point, we should have identified the IP address of three hosts on the target network: 10.10.2.45, 10.10.2.97, 10.10.2.112. Now, we will attempt to discover what services are running on these hosts, what versions of these services, and what operating systems.


Use the `nano` editor to create a new file - run

```
nano list-of-ips.txt
```

on the "recon" host. Copy and paste the list of IP addresses into the file:

```
10.10.2.45
10.10.2.97
10.10.2.112
```

then use Ctrl+O (and Enter to confirm file name) to save the file, and Ctrl+X to quit the editor.

On "recon", run

<pre>
sudo nmap -A -sV -O -iL list-of-ips.txt  | tee recon-fingerprint.txt
</pre>

This will direct `nmap` to try and "fingerprint" each host on the list of IP addresses we have just created.

On each target host, run the following commands to collect information about the host operating system and the services running on it:

<pre>
uname -sr | tee $(hostname -s)-os-name-version.txt
apache2 -v | tee $(hostname -s)-apache-version.txt
sshd -V 2>&1 | tee $(hostname -s)-openssh-version.txt
postconf -d mail_version | tee $(hostname -s)-postfix-version.txt
mysql --version  | tee $(hostname -s)-mysql-version.txt
</pre>

where:

* the first command (`uname -sr`) gets the name of the operating system and the OS kernel version.
* the second command (`apache2 -v`) tries to get the version number of the local Apache web server, if it is installed. 
* the third command (`sshd -V`) tries to get the version number of the local OpenSSH server, if it is installed. 
* the fourth command (`postconf -d mail_version`) tries to get the version number of the local Postfix mail server, if it is installed. 
* the fifth command (`mysql --version`) tries to get the version number of the local mySQL database server, if it is installed. 

For each of the last four commands: if the service is installed, you will see some output that includes the version number; if not, you will get an error message or a message that tells you how to install the service.

Which target host is running the Apache web server (default TCP port 80)? Which is running the Postfix STMP mail server (default TCP port 25)? Which is running the MySQL database server (default TCP port 3306)? Does `nmap` successfully collect this information? Compare the actual Linux kernel version and service version for each host, to `nmap`'s guess.

### Vulnerability discovery

> **Note**: some screenshots in your experiment may look different than the examples shown here, since you are using a newer version of Greenbone OpenVAS - however, the basic procedure should be as shown here.

Finally, we will use Greenbone OpenVAS to run a basic vulnerability scan on the hosts in our target network. 

We have already started the process of bringing up OpenVAS on the "recon" node. Assuming it is now ready, on the "recon" node, run

```
wget -qO- https://ipinfo.io/ip
```

to find out this host's public IP address. Then, in a browser, open the URL

[http://**IP**:9392](http://**IP**:9392)

where in place of **IP**, you substitute the public IP address you found. You may see a warning alerting you that "Your connection is not private" (or equivalent, depending on what browser you are using). Choose to proceed anyway (in Google Chrome, click "Advanced" and then "Proceed to... (unsafe)". 


When the login loads, log in with username **admin** and password **admin**.

![](/blog/content/images/2019/02/openvas-login.png)

> **Note**: If you are not able to log in, it is possible that the OpenVAS instance is not fully set up yet (it can take a LONG time) - you might try again later. Similarly, if you are not able to start a scan task (next step), you might have to wait and try again later.

Log in to the OpenVAS interface with username `admin` and password `admin`.

To use OpenVAS, we must first set up a "target" for each host in the target network. Then, we have to add a "scan task" for each one.

Click on "Configuration > Targets". To add a target, click on the star icon near the top left of the screen. Add a name. Next to "Hosts", make sure "manual" is selected, and in the text entry space put a comma-separated list of IP addresses for hosts on the target network. Change the "Alive Test" setting to "Consider Alive". Leave other settings at their defaults, then click "Save".

![](/blog/content/images/2021/02/scan-targets.png)

Now, add a scan. From the menu bar, choose "Scans > Tasks". Use the star icon near the top left of the screen again to set up a "New Task". Give your scan a name. Under "Scan Targets" make sure the "target" you previously set up is selected. Leave all other settings at their defaults, then click "Save".

![](/blog/content/images/2019/02/scan-target-network.png)

Now you are ready to start your scan. In the task dashboard, you should see your scan listed by name. In the "Actions" section next to it you will find a green button with the "Play" (►) symbol on it; click this button to start the scan.

![](/blog/content/images/2019/02/view-scan-report.png)

To see the scan report, click on the number in parentheses in the "Reports" column next to your scan. This will show you the reports for the scan, including the current unfinished one:

![](/blog/content/images/2019/02/reports-dash.png)

Refresh the page to see the latest scan status. When the status shows as "Done", click on the "Date" column entry to see the report details. Then, you can click on any vulnerability in the report to see more details.

![](/blog/content/images/2019/02/vulnerability-list.png)

**Note**: If at some point you see the error message "An internal error occurred. Diagnostics: Could not authenticate to manager daemon.", click on "Assumed sane state" to continue.

## Notes

Last updated: September 2024, with the help of Ufuk Usubütün.

### Exercise

Use the data you have collected to answer the following questions, and show evidence to support your answers.

* **ICMP echo request scan**: Make a note of which hosts on the target network `nmap` sent an ICMP echo request to. Which hosts on the target network responded to the ICMP request? Which hosts do you think are configured to ignore ICMP echo requests?

* **TCP SYN scan**: Make a note of which hosts on the target network responded to the TCP SYN. What was the response in each case (i.e. what TCP flags were set)? Why might some hosts respond differently from others?

* **Service and host fingerprinting**: Which target host is running the Apache web server (default TCP port 80)? Which is running the Postfix STMP mail server (default TCP port 25)? Which is running the MySQL database server (default TCP port 3306)? Does `nmap` successfully collect this information? Compare the actual Linux kernel version and service version for each host, to `nmap`'s guess.